# Public Key Encryption Systems - RSA

从这一期开始，我们要聊非对称加密了，非对称加密的代表就是公钥私钥加密。

上一期我们聊了 `Diffie–Hellman key exchange 迪菲-赫尔曼密钥交换`,受这个的启发，有三个人在1977年提出了RSA加密算法，这三个人分别是：罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman），RSA 就是他们三人姓氏开头字母拼在一起组成的。

## RSA的数学原理和证明

网上关于RSA讲解的文章非常多，感兴趣的同学可以自行搜索，比如`阮一峰`老师曾讲过RSA的算法原理：

- RSA算法原理（一）[https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html](https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)

- RSA算法原理（二）[https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html](https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)

## RSA Python简单测试

我们这里就按照维基百科，简单的通过Python代码来做一个RSA算法的加密解密过程。其中可能会需要一些简单的数学知识，比如什么是`质数`，什么叫`互为质数`，欧拉函数等等。

### 公钥私钥的生成

生成公钥私钥一共有4步，具体的证明我们就不讲了。


第一步，随机选择俩个不同的`质数`，或者叫`素数`，p和q，得到 `N=p*q`

```python
import random


def is_prime(n):
    return n > 1 and all(n % i for i in range(2, int(n ** 0.5) + 1))


def get_prime(size):

    while True:
        num = random.randrange(size, size ** 2)
        if is_prime(num):
            return num


p = get_prime(100)
q = get_prime(100)

N = p * q

print(f"p={p}")
print(f"q={q}")
print(f"N=p*q={p*q}")

```

比如结果如下（随机）


```python
p=421
q=5441
N=p*q=2290661
```


第二步，根据`欧拉函数` 求出 r, 证明方法就不展开了。

```
r =  φ(N) =  φ(p) x  φ(q) = (p-1)(q-1)
```

``` python
>>> p=421
>>> q=5441
>>> r = (p - 1)*(q - 1)
>>> r
2284800
>>>
```

第三步，随机选择一个整数e，条件是1< e < φ(N)，且e与φ(N) 互质。

 φ(N) = 2284800, 也就是在1到2284800之间，选择一个数e，e和2284800互为质数（也就是他俩的最大公约数=1）

满足条件的e很多，如果一个一个算，这一步会耗费大量时间，通常我们会让 `e=65537`，至于为什么，可以参考这篇文章[https://www.johndcook.com/blog/2018/12/12/rsa-exponent/](https://www.johndcook.com/blog/2018/12/12/rsa-exponent/)


下面是如果你真的想去随机找e，代码如下，如果r值很大，运行时间会很长。

```python
import math
import random

p=421
q=5441
r = (p - 1)*(q - 1)

def get_e(r):
    e_list = []
    for i in range(2, r):
        if math.gcd(i, r) == 1:
            e_list.append(i)
            print(i)
    return random.choice(e_list)

e = get_e(r)
print(e)
```

第四步，求得e关于r的模逆元，命名为d，如果模逆元不存在，则重复步骤一二三。


```python

p=421
q=5441
r = (p - 1)*(q - 1)
e = 65537

def get_d(e, r):
    for d in range(2, r):
        if d*e % r == 1:
            return d

    return False

d = get_d(e, r)
if d:
    print(d)
```

得到 `d=489473`

最后，将N和e封装成公钥，N和d封装成私钥。

公钥: N = 2290661, e = 65537

私钥：N = 2290661, d = 489473


### 加密和解密


加密用到公钥（N，e），假如要加密的消息m=100，则加密就是计算 m的e次方然后对n取模

```python
m = 100
N = 2290661
e = 65537

cipher = m**e % N

print(cipher)
```

密文为 cipher = 71194


解密要用到私钥（N，d），解密就是把密文进行d次方，然后对N取余

```python
N = 2290661
d = 489473
cipher = 71194

plaintext = cipher**d % N

print(plaintext)
```

得到明文 plaintext = 100


## RSA的安全性

通过分析RSA的加密算法公钥私钥的生成过程，不难看到攻击者如果要破解获取到私钥，必须通过N进行因数分解得到p和q

N = p x q

而因数分解这个事，除了暴力穷举，没有别得办法，但如果N选的足够大，暴力破解是不可能完成的任务（除非量子计算机问世）。

维基百科说“2020年为止，世界上还没有任何可靠的攻击RSA算法的方式”，实际上到目前2022年，应该也没有什么可靠的算法。

### N多大才算安全？

目前大多数的SSH客户端sshkey都会默认用RSA生成3072位key，因为这是最低安全标准，业界的共识一般是推荐使用4096位。

那这里的RSA key的位数是什么意思呢？ 这个位数实际上指的是N的二进制表示的位数。比如对于我们的前面的演示：


```python
p=421
q=5441
N=p*q=2290661
```

N转换成二进制是1000101111001111100101，也就是22位，所以最后生成的key就是22位的。

以下内容来自维基百科：

针对RSA最流行的攻击一般是基于大数因数分解。1999年，RSA-155 (512 bits)被成功分解，花了五个月时间（约8000 MIPS年）和224 CPU hours在一台有3.2G中央内存的Cray C916计算机上完成。


RSA-155表示如下：

```
39505874583265144526419767800614481996020776460304936454139376051579355626529450683609
727842468219535093544305870490251995655335710209799226484977949442955603

= 3388495837466721394368393204672181522815830368604993048084925840555281177×
  11658823406671259903148376558383270818131012258146392600439520994131344334162924536139
```

2009年12月12日，编号为RSA-768（768 bits, 232 digits）数也被成功分解。这一事件威胁了现通行的1024-bit密钥的安全性，普遍认为用户应尽快升级到2048-bit或以上。

RSA-768表示如下：

```
123018668453011775513049495838496272077285356959533479219732245215172640050726
365751874520219978646938995647494277406384592519255732630345373154826850791702
6122142913461670429214311602221240479274737794080665351419597459856902143413

= 3347807169895689878604416984821269081770479498371376856891
  2431388982883793878002287614711652531743087737814467999489×
  3674604366679959042824463379962795263227915816434308764267
  6032283815739666511279233373417143396810270092798736308917
```

### Python大因数分解

暴力的方法进行大因数分解并不难，也有很多现成的Python库可以用，比如sympy就可以。

以上面我们的N为例

```python
p=421
q=5441
N=p*q=2290661
```

通过N去破解p和q非常简单，这个N只有22位，一秒就可以出结果。

```python
from sympy import factorint

a = factorint(2290661)
print(a)
```

得到的结果a是

```python
{421: 1, 5441: 1}
```

也就是421和5441.


### 最后

当然，针对RSA的攻击方法还有很多，这里就不展开了，感兴趣的同学可以自行查找相关资料。